---
title: "Project1"
name:  "Matt and Isaac"
date:  "10-02-24"
format: html
editor: visual
---

## Task 1

Build the URL as in the notes, then use GET from the httr package.

```{r}
library("tidyverse")
library("tidycensus")
library("jsonlite")

#Example API call
#api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&key=YOUR_KEY

#Don't use, but gives some information that could be useful for later development
#ex_URL <- "https://api.census.gov/data/2022/acs/acs1/pums/variables.json"

#Convert URL to tibble

url_to_tibble <- function(url = NULL) {
    raw_data <- httr::GET(url)
    parsed_data <- fromJSON(rawToChar(raw_data$content))
    return (as_tibble(parsed_data))
}

url_to_tibble("https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24")

```

The tibble returned in url_to_tibble will have variable names "V1", "V2", etc., when instead the variable names should correspond to the entries in the 
first row of data (and the first row should be deleted since it does not consist of valid observations). Below is an improved url_to_tibble function which renames the variables to the entries in the first row and deletes the first row. 

```{r}
url_to_tibble <- function(url = NULL) {
    #us url to access data
    raw_data <- httr::GET(url)
    
    #data is given as a JSON file, so we need to parse it with rawToChar
    #then format it as a tibble
    parsed_data <- fromJSON(rawToChar(raw_data$content))
    base_tib <- as_tibble(parsed_data)
    
    m <- nrow(base_tib)
    n <- ncol(base_tib)
    
    #need to change column names of base_tib so that it matches the first row
    for (i in 1:n) {
      colnames(base_tib)[i] <- base_tib[[1,i]]
    }
    
    #now get rid of first row since they are not valid observations
    updated_tib <- base_tib[2:m, ]
    
    return (updated_tib)
}

url_to_tibble("https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24")
```





#Build a URL.  Start with a toy model.

```{r}
load_data_toy <- function(year=2022,SEX=2,AGEP=1,PWGTP=1){
  if (year %in% -c(2010:2022)){
    stop("Select a year from 2010 through 2022")
  }
  base <- paste("https://api.census.gov/data", as.character(year), "acs", "acs1", "pums?", sep = "/")
#  return(base)
  if (SEX %in% -c(1,2)){
    stop("Select 1 or 2 for SEX")
  }
  if (AGEP %in% -c(1:99)){
    stop("Select a value from 1 through 99 for AGEP")
  }
  if (PWGTP %in% -c(1:9999)){
    stop("Select a value from 1 through 9999 for PWGTP")
  }
  base <- paste0(base, "get=", "SEX")
  URL <- paste(base, "AGEP", "PWGTP", sep = ",")
  return(URL)
#  raw_data <- httr::GET(URL)
#  parsed_data <- fromJSON(rawToChar(raw_data$content))
#  return (tibble(parsed_data))
}

load_data_toy()
```



```{r}
#https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24

#load_data_pums <- function(geography, AGEP=NULL, PWGTP=1, SEX=NULL, key, year = 2022, show_call = FALSE) {
# base <- paste("https://api.census.gov/data", as.character(year), "acs", "acs1", "pums?", sep = "/")
# if (){ 
#   message("Using the ACS Data Profile") base <- paste0(base, "/profile") 
# }
#}
```

My (i.e. Isaac) attempt at the query function.

```{r}
pums_url_builder <- function(year = 2022, num_vars = c("AGEP", "PWGTP"),
                             cat_vars = c("SEX"), geo_lev = "All") {
  
  #verify user input is valid
  if (!(year %in% c(2010:2022))) {
    stop("Year must be between 2010 and 2022!")
  }
  else if (!all(is.element(num_vars, list("AGEP", "PWGTP", "GASP", "GRPIP", 
                                          "JWAP", "JWDP", "JWNMP")))) {
    stop("Numeric variables must be within the set {AGEP, PWGTP, GASP, GRPIP, 
         JWAP, JWDP, JWNMP}, and furthermore PWGTP must also be included.")
    if (!(is.element("PWGTP", num_vars))) {
      stop("PWGTP must always be included!")
    }
  }
  else if (!all(is.element(cat_vars, list("FER", "HHL", "HISPEED", "JWAP", 
                                          "JWDP", "JWTRNS", "SCH", "SCHL", "SEX"
                                          )))) {
    stop("Categorical variables must be within the set {FER, HHL, HISPEED, JWAP,
         JWDP, JWTRNS, SCH, SCHL, SEX} and cannot be empty.")
    if (length(cat_vars) == 0) {
      stop("At least one categorical variable must be returned!")
    }
  }
  else if (!all(is.element(geo_lev, list("All", "Region", "Division", "STATE"
                                         )))) {
    stop("Geography level must be within the set {All, Region, Division, State}
         .")
  }
  
  #base url: contains year only
  base_url <- paste0("https://api.census.gov/data/year/acs/acs1/pums?get=", 
                     as.character(year))
  
  #concatenate base url with other arguments chosen by user
  updated_url <- cat(base_url, num_vars, cat_vars, geo_lev, sep=",")

  return(updated_url)
}
pums_url_builder()
```
Still not quite right because apparently the resulting url does not exist, but I am not sure how to fix....

