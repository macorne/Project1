{
  "hash": "59fa8173c38ac4495c5e7de559593f47",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Project1_Sandbox\"\nformat: html\neditor: visual\n---\n\n\n## Task 1\n\nBuild the URL as in the notes, then use GET from the httr package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyverse\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(\"tidycensus\")\nlibrary(\"jsonlite\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n```\n\n\n:::\n\n```{.r .cell-code}\n#Example API call\n#api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24&key=YOUR_KEY\n\n#Don't use, but gives some information that could be useful for later development\n#ex_URL <- \"https://api.census.gov/data/2022/acs/acs1/pums/variables.json\"\n\n#Convert URL to tibble\n\nurl_to_tibble <- function(url = NULL) {\n    raw_data <- httr::GET(url)\n    parsed_data <- fromJSON(rawToChar(raw_data$content))\n    return (as_tibble(parsed_data))\n}\n\nurl_to_tibble(\"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 44,080 × 4\n   V1    V2    V3    V4   \n   <chr> <chr> <chr> <chr>\n 1 SEX   PWGTP MAR   SCHL \n 2 2     6     5     24   \n 3 2     23    2     24   \n 4 1     23    3     24   \n 5 1     80    5     24   \n 6 1     16    1     24   \n 7 1     107   3     24   \n 8 2     10    5     24   \n 9 1     22    1     24   \n10 2     127   5     24   \n# ℹ 44,070 more rows\n```\n\n\n:::\n:::\n\n\nThe tibble returned in url_to_tibble will have variable names \"V1\", \"V2\", etc., when instead the variable names should correspond to the entries in the first row of data (and the first row should be deleted since it does not consist of valid observations). Below is an improved url_to_tibble function which renames the variables to the entries in the first row and deletes the first row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl_to_tibble <- function(url = NULL) {\n    #us url to access data\n    raw_data <- httr::GET(url)\n    \n    #data is given as a JSON file, so we need to parse it with rawToChar\n    #then format it as a tibble\n    parsed_data <- fromJSON(rawToChar(raw_data$content))\n    base_tib <- as_tibble(parsed_data)\n    \n    m <- nrow(base_tib)\n    n <- ncol(base_tib)\n    \n    #need to change column names of base_tib so that it matches the first row\n    for (i in 1:n) {\n      colnames(base_tib)[i] <- base_tib[[1,i]]\n    }\n    \n    #now get rid of first row since they are not valid observations\n    updated_tib <- base_tib[2:m, ]\n    \n    return (updated_tib)\n}\n\nurl_to_tibble(\"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   <chr> <chr> <chr> <chr>\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n```\n\n\n:::\n:::\n\n\n#Build a URL. Start with a toy model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#load_data_toy <- function(year=2022,chr_vars=c(\"SEX\"),num_vars=c(\"AGEP\",\"PWGTP\")){\n#  if (year %in% -c(2010:2022)){\n#    stop(\"Select a year from 2010 through 2022\")\n#  }\n#  base <- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \"acs1\", \"pums?\", sep = \"/\")\n#  return(base)\n  \n#  if (SEX %in% -c(1,2)){\n#    stop(\"Select 1 or 2 for SEX\")\n#  }\n#  if (AGEP %in% -c(1:99)){\n#    stop(\"Select a value from 1 through 99 for AGEP\")\n#  }\n#  if (PWGTP %in% -c(1:9999)){\n#    stop(\"Select a value from 1 through 9999 for PWGTP\")\n#  }\n#  base <- paste0(base, \"get=\", \"SEX\")\n#  URL <- paste(base, \"AGEP\", \"PWGTP\", sep = \",\")\n#  return(URL)\n#  raw_data <- httr::GET(URL)\n#  parsed_data <- fromJSON(rawToChar(raw_data$content))\n#  return (tibble(parsed_data))\n#}\n\n#load_data_toy()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\n\npums_url_builder <- function(year = 2022, num_vars = c(\"AGEP\", \"PWGTP\"),\n                             cat_vars = c(\"SEX\"), geo_lev = \"All\") {\n  \n  #verify user input is valid\n  if (!(year %in% c(2010:2022))) {\n    stop(\"Year must be between 2010 and 2022!\")\n  }\n  else if (!all(is.element(num_vars, list(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \n                                          \"JWAP\", \"JWDP\", \"JWNMP\")))) {\n    stop(\"Numeric variables must be within the set {AGEP, PWGTP, GASP, GRPIP, \n         JWAP, JWDP, JWNMP}, and furthermore PWGTP must also be included.\")\n    if (!(is.element(\"PWGTP\", num_vars))) {\n      stop(\"PWGTP must always be included!\")\n    }\n  }\n  else if (!all(is.element(cat_vars, list(\"FER\", \"HHL\", \"HISPEED\", \"JWAP\", \n                                          \"JWDP\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"\n                                          )))) {\n    stop(\"Categorical variables must be within the set {FER, HHL, HISPEED, JWAP,\n         JWDP, JWTRNS, SCH, SCHL, SEX} and cannot be empty.\")\n    if (length(cat_vars) == 0) {\n      stop(\"At least one categorical variable must be returned!\")\n    }\n  }\n  else if (!all(is.element(geo_lev, list(\"All\", \"Region\", \"Division\", \"STATE\"\n                                         )))) {\n    stop(\"Geography level must be within the set {All, Region, Division, State}\n         .\")\n  }\n  \n  #base url: contains year only\n  base_url <- paste0(\"https://api.census.gov/data/year/acs/acs1/pums?get=\", \n                     as.character(year))\n  \n  #concatenate base url with other arguments chosen by user\n  for (i in 1:length(cat_vars)){\n    updated_url <- paste(base_url, cat_vars[i], sep=\",\")\n  }\n  for (j in 1:length(num_vars)){\n    updated_url <- paste(updated_url, num_vars[j], sep=\",\")\n  }\n  updated_url <- paste(updated_url, geo_lev, sep=\",\")\n\n  return(updated_url)\n}\npums_url_builder()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://api.census.gov/data/year/acs/acs1/pums?get=2022,SEX,AGEP,PWGTP,All\"\n```\n\n\n:::\n:::\n\n\nMy (i.e. Isaac) attempt at the query function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\n\npums_url_builder <- function(year = 2022, variables= c(num_vars,cat_vars), \n                             geo_lev = \"All\") {\n  \n  #verify user input is valid\n  num_vars <- c(\"AGEP\", \"PWGTP\")\n  cat_vars <- c(\"SEX\")\n  if (!(year %in% c(2010:2022))) {\n    stop(\"Year must be between 2010 and 2022!\")\n  }\n  else if (!all(is.element(num_vars, list(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \n                                          \"JWAP\", \"JWDP\", \"JWNMP\")))) {\n    stop(\"Numeric variables must be within the set {AGEP, PWGTP, GASP, GRPIP, \n         JWAP, JWDP, JWNMP}, and furthermore PWGTP must also be included.\")\n    if (!(is.element(\"PWGTP\", num_vars))) {\n      stop(\"PWGTP must always be included!\")\n    }\n  }\n  else if (!all(is.element(cat_vars, list(\"FER\", \"HHL\", \"HISPEED\", \"JWAP\", \n                                          \"JWDP\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"\n                                          )))) {\n    stop(\"Categorical variables must be within the set {FER, HHL, HISPEED, JWAP,\n         JWDP, JWTRNS, SCH, SCHL, SEX} and cannot be empty.\")\n    if (length(cat_vars) == 0) {\n      stop(\"At least one categorical variable must be returned!\")\n    }\n  }\n  else if (!all(is.element(geo_lev, list(\"All\", \"Region\", \"Division\", \"STATE\"\n                                         )))) {\n    stop(\"Geography level must be within the set {All, Region, Division, State}\n         .\")\n  }\n  \n  #base url: contains year only\n  base_url <- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \"acs1\", \"pums?get=\", sep=\"/\")\n  \n  #concatenate base url with other arguments chosen by user\n  chars <- \"\"\n  for (i in 1:length(cat_vars)){\n    chars <- paste(chars,cat_vars[i],sep=\",\")\n  }\n  chars <- substr(chars,2,str_length(chars))\n  updated_url <- paste(base_url,chars,sep=\"\")\n  \n  nums <- \"\"\n  for (j in 1:length(num_vars)){\n    nums <- paste(nums,num_vars[j],sep=\",\")\n  }\n  updated_url <- paste(updated_url, nums, sep=\"\")\n  updated_url <- paste(updated_url, geo_lev, sep=\",\")\n\n  return(updated_url)\n}\npums_url_builder()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,AGEP,PWGTP,All\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\n#Matt attempt\n#Would use a prompting system for user to build URL\n#https://www.geeksforgeeks.org/taking-input-from-user-in-r-programming/\n\n# R program to illustrate\n# taking input from the user\n \n# taking multiple inputs\n# using braces \n#ex_url_bldr <- function(year=2022, variables){\n#    var1 = readline(\"Enter 1st variable : \");\n#    var2 = readline(\"Enter 2nd variable : \");\n#    var3 = readline(\"Enter 3rd variable : \");\n    \n#    base_url <- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \"acs1\", \"pums?get=\", sep=\"/\")\n    \n#    var_piece <- paste(var1,var2,var3,sep=\",\")\n    \n#    ex_url <- paste(base_url,var_piece)\n#    ex_url <- gsub(\" \",\"\",ex_url)\n    \n#    return(ex_url)\n#}\n\n#ex_url_bldr()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nex_fn <- function(year=2022,...,GEO=\"All\"){\n  vars <- list(...)\n#  vars[[1]] <- c(SEX=NA)\n#  vars[[2]] <- c(AGEP=\"\",PWGTP=\"\")\n#  vars[[3]] <- c(year=2022)\n#  vars[[4]] <- c(GEO=\"All\")\n  \n  vars[[1]] <- c(c(\"SEX\"),c(...)) #cat_vars\n  vars[[2]] <- c(c(\"AGEP\",\"PWGTP\"),c(...)) #num_vars\n#  vars[[3]] <- c(year)\n#  vars[[4]] <- c(GEO=\"All\")\n  \n    #verify user input is valid\n  if (!(year %in% c(2010:2022))) {\n    stop(\"Year must be between 2010 and 2022!\")\n  }\n  \n  for (x in vars[[1]]){\n    if (!(x %in% c(\"FER\", \"HHL\", \"HISPEED\", \"JWAP\", \n                                          \"JWDP\", \"JWTRNS\", \"SCH\", \"SCHL\", \n                      \"SEX\", \"GEO\"\n    ))){\"Character variable must be among FER, HHL, HISPEED, JWAP, \n                                          JWDP, JWTRNS, SCH, SCHL, SEX, GEO\"\n                                          }\n  }\n  \n  #base url: contains year only\n  base_url <- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \"acs1\", \"pums?get=\", sep=\"/\")\n  \n  #concatenate base url with other arguments chosen by user\n  chars <- \"\"\n  for (i in 1:length(vars[[1]])){\n    chars <- paste(chars,vars[[1]][i],sep=\",\")\n  }\n  chars <- substr(chars,2,str_length(chars))\n  updated_url <- paste(base_url,chars,sep=\"\")\n  \n  nums <- \"\"\n  for (j in 1:length(vars[[2]])){\n    nums <- paste(nums,vars[[2]][j],sep=\",\")\n  }\n  updated_url <- paste(updated_url, nums, sep=\"\")\n  updated_url <- paste(updated_url, GEO, sep=\",\")\n\n  return(updated_url)\n}\n\nex_fn(year=2020,GEO=\"state\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://api.census.gov/data/2020/acs/acs1/pums?get=SEX,AGEP,PWGTP,state\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#vec <- c(1,2)\n#foovec <- function(...){c(...)}\n#c(vec,foovec(3,4))\n\n#foo <- function(...){\n#  foovec <- c(...)\n#  vec <- c(1,2)\n#  return(c(vec,foovec))\n#}\n#foo(3,4)\n\n#foo <- function(...,year=2022,GEO=\"All\"){\n#  year <- 2022\n#  GEO <- \"All\"\n#  vars <- list()\n#  vars[[1]] <- list(...)\n#  vars[[2]] <- vars[-c(1,length(vars[[1]]))]\n  \n#  if (!(year %in% 2010:2022)){\n#    stop(\"Year must be from 2010 through 2022\")\n#  }\n#  for (x in vars[[1]]){\n#    if (!((x %in% c(\"A\",\"B\",\"C\")) | missing(x))){\n#    stop(\"Character variables must be one of A, B, or C or not specified\")\n#    }\n#  }\n#  for (y in vars[[2]]){\n#    if (!((y %in% c(1,2,3)) | missing(y))){\n#    stop(\"Numeric variables must be one of 1, 2, or 3 or not specified\")\n#    }\n#  }\n#  strng <- paste(as.character(year),x,GEO, sep=\" \")\n#  return(strng)\n#}\n#foo()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Trying a suggestion to build a URL from \n#https://stackoverflow.com/questions/5080972/using-multiple-ellipses-arguments-in-r\n#Only problems:  (1) Have to write list() to input categorical and numerical variables\n#(2) Doesn't have the '&' separators for things like KEY=\n#(3) Order within the URL might not be right for the query\n\nbuild_url <- function(cat_vars=list(),num_vars=list(),...,year=2022,GEO=\"All\"){\n  if (!(year %in% 2010:2022)){\n    stop(\"Year must be from 2010 through 2022\")\n  }\n  if (!(GEO %in% list(\"region\",\"division\",\"state\",\"All\"))){\n    stop(\"GEO must be one of region, division, state, or all\")\n  }\n  do.call(cat_fxn, cat_vars)\n  do.call(num_fxn, num_vars)\n  cat_dflts <- c(\"SEX\")\n  num_dflts <- c(\"AGEP\",\"PWGTP\")\n  \n  base_url <- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \n                    \"acs1\", \"pums?get=\", sep=\"/\")\n  \n  for (k in 1:length(cat_dflts)){\n    cat_dflts2 <- paste(cat_dflts[k], sep=\",\")\n  }\n  \n  updated_url <- paste(base_url,cat_dflts2,sep=\"\")\n  \n  for (l in 1:length(num_dflts)){\n    updated_url <- paste(updated_url, num_dflts[l], sep=\",\")\n  }\n  \n  updated_url <- paste(updated_url, GEO, sep=\",\")\n  \n  chars <- \"\"\n  for (i in 1:length(cat_vars)){\n    if (length(cat_vars) < 1){\n      break\n    }\n    else{\n      chars <- paste(chars,cat_vars[i],sep=\",\")\n    }\n  }\n#  chars <- substr(chars,2,str_length(chars))\n  updated_url <- paste(updated_url,chars,sep=\"\")\n  \n  nums <- \"\"\n  for (j in 1:length(num_vars)){\n    if (length(num_vars) < 1){\n      break\n    }\n    else {\n      nums <- paste(nums,num_vars[j],sep=\",\")\n    }\n  }\n  updated_url <- paste(updated_url, nums, sep=\"\")\n  \n  return(updated_url)\n  \n#  strng <- paste(base_url,cat_vars,num_vars,num_dflts,GEO,sep=\",\")\n#  return(strng)\n}\n\ncat_fxn <- function(...){\n  cat_vars <- list(...)\n  for (x in cat_vars){\n    if (!(x %in% list(\"FER\", \"HHL\", \"HISPEED\", \"JWAP\", \"JWDP\", \"JWTRNS\", \n                           \"SCH\", \"SCHL\", \"SEX\", \"GEO\"))){\n    stop(\"Categorical variables must be within the set {FER, HHL, HISPEED, JWAP,\n         JWDP, JWTRNS, SCH, SCHL, SEX, GEO} and cannot be empty.\")\n    }\n  }  \n}\n\nnum_fxn <- function(...){\n  num_vars <- list(...)\n  for (y in num_vars){\n    if (!(y %in% list(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \n                                          \"JWAP\", \"JWDP\", \"JWNMP\"))){\n    stop(\"Numeric variables must be within the set {AGEP, PWGTP, GASP, GRPIP, \n         JWAP, JWDP, JWNMP}; PWGTP is always returned, and one numeric variable \n         besides PWGTP must be included.\")\n    }\n  }\n}\n# function call\nbuild_url()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,AGEP,PWGTP,All\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}