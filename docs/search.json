[
  {
    "objectID": "Project1_Deploy.html",
    "href": "Project1_Deploy.html",
    "title": "Project 1",
    "section": "",
    "text": "The goal of this project is to query the “Public Use Microdata Sample” (PUMS) API from the Census Bureau. We do this by first building the URL to contact a particular endpoint of the PUMS API. In particular, we will go with the example call provided in the PUMS API under their most recent year, 2022, which we store as a string.\n\nURL_pums &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n\nNext we use the httr::GET() function to contact the website and explore its structure.\n\npums_info &lt;- httr::GET(URL_pums)\nstr(pums_info, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2024-10-07 02:02:25\"\n $ times      : Named num [1:6] 0 0.00292 0.09915 0.28703 0.52675 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nThis is a lot of information and not very clear or readable, so we will use the jsonlite package to parse this data.\n\nlibrary(jsonlite)\nlibrary(tibble)\n\n#parse data using rawToChar() function \nparsed &lt;- fromJSON(rawToChar(pums_info$content))\n\n#turn parsed data into nice tibble\nacs_estimates_info &lt;- as_tibble(parsed)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\nacs_estimates_info\n\n# A tibble: 44,080 × 4\n   V1    V2    V3    V4   \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 SEX   PWGTP MAR   SCHL \n 2 2     6     5     24   \n 3 2     23    2     24   \n 4 1     23    3     24   \n 5 1     80    5     24   \n 6 1     16    1     24   \n 7 1     107   3     24   \n 8 2     10    5     24   \n 9 1     22    1     24   \n10 2     127   5     24   \n# ℹ 44,070 more rows\n\n\nThis is not quite what we want because the column names are “V1”, “V2”, “V3”, “V4”, default names, and the first row of observations are “SEX”, “PWGTP”, “MAR”, “SCHL”, are what should be the columns names. The following code will fix this:\n\nrow_length &lt;- nrow(acs_estimates_info)\n\nacs_estimates_info_updated &lt;- tibble(\"SEX\" = acs_estimates_info$V1[2:row_length], \"PWGTP\" = acs_estimates_info$V2[2:row_length], \"MAR\" = acs_estimates_info$V3[2:row_length], \"SCHL\" = acs_estimates_info$V4[2:row_length])\n\nacs_estimates_info_updated\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n\n\n\nNext we want to automate things. First we define a helper function which will take in a URL that accesses data from the PUMS API, and returns as output a nicely formatted tibble. Note that in the PUMS API, the data is always formatted with the first row consisting of the variable names, so we will need to take this into account for our helper function!\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ purrr     1.0.2\n✔ forcats   1.0.0     ✔ readr     2.1.5\n✔ ggplot2   3.5.1     ✔ stringr   1.5.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()  masks stats::filter()\n✖ purrr::flatten() masks jsonlite::flatten()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nurl_to_tibble &lt;- function(url = NULL, year = 2022) {\n    #us url to access data\n    raw_data &lt;- httr::GET(url)\n    \n    #data is given as a JSON file, so we need to parse it with rawToChar\n    #then format it as a tibble\n    parsed_data &lt;- fromJSON(rawToChar(raw_data$content))\n    base_tib &lt;- as_tibble(parsed_data)\n    \n    m &lt;- nrow(base_tib)\n    n &lt;- ncol(base_tib)\n    \n    #need to change column names of base_tib so that it matches the first row\n    for (i in 1:n) {\n      colnames(base_tib)[i] &lt;- base_tib[[1,i]]\n    }\n    \n    #now get rid of first row since they are not valid observations\n    updated_tib &lt;- base_tib[2:m, ]\n    \n    final_tib &lt;- updated_tib |&gt; \n      mutate(YEAR = as.character(year)) |&gt; \n      select(YEAR, everything())\n    \n    return (final_tib)\n}\n\nmy_tib &lt;- url_to_tibble(\"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX,MAR&SCHL=24\")\n\nThis works. Now we want to define a function that will query the PUMS API and allows the user to specify:\n\nyear of survey (with 2022 being the default year)\n\nneed to verify that the value given is between 2010 and 2022\n\nthe numeric variables to be returned (with AGEP and PWGTP as default, and PWGTP always being returned)\n\noptions for the user should be AGEP, GASP, GRPIP, JWAP (time), JWDP (time), and JWMNP\nfunction needs to turn variables into numeric values or time values where appropriate and check that the variables asked for are in the above set\none numeric variable other than PWGTP must also be returned\n\nthe categorical variables to be returned (with SEX as default)\n\noptions for the user should be FER, HHL, HISPEED, JWAP, JWDP, JWTRNS, SCH, SCHL, and SEX\nfunction needs to turn variables into factors with appropriate levels, where appropriate, and also check that the variables asked for are in the above set\none categorical variable must be returned\n\ngeography level (i.e. All, Region, Division, or STATE, with ALL as default)\n\nfunction needs to check that the value specified by the user is in the set above\n\nan optional argument to subset the data\n\nuser should be able to specify specific Regions, Divisions, or STATES for this part (and only those specified geography levels would be returned)\n\n\nIsaac added an optional user argument, geo_lev_value, which allows the user to subset the data by specific regions, divisions, or states, provided they select the corresponding geography level.\n\n#Need default arguments to build the url below\n#https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX\n#If user wants to specify a geography level (e.g. by state) other than the default\n#then the url should look something like\n#https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=state:* \n\nlibrary(stringi)\n\npums_url_builder &lt;- function(year = 2022, num_vars = c(\"AGEP\", \"PWGTP\"),\n                             cat_vars = c(\"SEX\"), geo_lev = \"all\", geo_lev_value = NULL) {\n  \n  #verify user input is valid\n  if (!(year %in% c(2010:2022))) {\n    stop(\"Year must be between 2010 and 2022!\")\n  }\n  else if (!all(is.element(num_vars, c(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \n                                          \"JWAP\", \"JWDP\", \"JWNMP\")))) {\n    stop(\"Numeric variables must be within the set {AGEP, PWGTP, GASP, GRPIP, \n         JWAP, JWDP, JWNMP}, and furthermore PWGTP must also be included.\")\n    if (!(is.element(\"PWGTP\", num_vars))) {\n      stop(\"PWGTP must always be included!\")\n    }\n  }\n  else if (!all(is.element(cat_vars, c(\"FER\", \"HHL\", \"HISPEED\", \"JWAP\", \n                                          \"JWDP\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"\n                                          )))) {\n    stop(\"Categorical variables must be within the set {FER, HHL, HISPEED, JWAP,\n         JWDP, JWTRNS, SCH, SCHL, SEX} and cannot be empty.\")\n    if (length(cat_vars) == 0) {\n      stop(\"At least one categorical variable must be returned!\")\n    }\n  }\n  else if (!all(is.element(geo_lev, c(\"all\", \"region\", \"division\", \"state\"\n                                         )))) {\n    stop(\"Geography level must be within the set {all, region, division, state}\n         .\")\n  }\n  \n  #base url: contains year only\n  base_url &lt;- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \"acs1\", \"pums?get=\", sep=\"/\")\n  \n  #create a string consisting of the numeric arguments chosen by user, then add \n  #this to base url\n  nums &lt;- \"\" #initialize empty string\n  for (i in 1:length(num_vars)){\n    nums &lt;- paste(nums,num_vars[i],sep=\",\")\n  }\n  nums &lt;- substr(nums, 2, stri_length(nums)) #delete \",\" in the beginning of nums\n  updated_url &lt;- paste0(base_url, nums)\n  \n  #do same for categorical arguments chose by user\n  chars &lt;- \"\" #initialize empty string\n  for (i in 1:length(cat_vars)){\n    chars &lt;- paste(chars,cat_vars[i],sep=\",\")\n  }\n  updated_url &lt;- paste0(updated_url, chars)\n  \n  #concatenate chosen geography level, and value for said level if given\n  if (geo_lev != \"All\") {\n    updated_url &lt;- paste0(updated_url, \"&for=\", geo_lev, \":\")\n    if (is.null(geo_lev_value) == FALSE) {\n      if (typeof(geo_lev_value) != \"character\") {\n        stop(\"Value for geography level must be of the form \\\"XX\\\", where X is a number between\n             0 and 9!\")\n      }\n      else if (stri_length(geo_lev_value) != 2) {\n        stop(\"Value for geography level must be of the form \\\"XX\\\", where X is a number between\n             0 and 9!\")\n      }\n      else if (!(is.element(unlist(strsplit(geo_lev_value, split=\"\"))[1], 0:9) | is.element\n               (unlist(strsplit(geo_lev_value,split=\"\"))[2], 0:9))) {\n        stop(\"Value for geography level must be of the form \\\"XX\\\", where X is a number between\n             0 and 9!\")\n      }\n      else {\n        updated_url &lt;- paste0(updated_url, as.character(geo_lev_value)) \n      }\n    }\n    else if (geo_lev == \"all\" & is.null(geo_lev_value) == FALSE) {\n      stop(\"You cannot specify a geography level value without picking a specific geography \n           level (i.e. region, division, or state.\")\n    }\n    else {\n      updated_url &lt;- paste0(updated_url, \"*\")\n    }\n  }\n\n  return(updated_url)\n}\npums_url_builder(geo_lev = \"state\", geo_lev_value = \"16\")\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=state:16\""
  },
  {
    "objectID": "Project1_Deploy.html#querying-census-api",
    "href": "Project1_Deploy.html#querying-census-api",
    "title": "Project 1",
    "section": "",
    "text": "The goal of this project is to query the “Public Use Microdata Sample” (PUMS) API from the Census Bureau. We do this by first building the URL to contact a particular endpoint of the PUMS API. In particular, we will go with the example call provided in the PUMS API under their most recent year, 2022, which we store as a string.\n\nURL_pums &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n\nNext we use the httr::GET() function to contact the website and explore its structure.\n\npums_info &lt;- httr::GET(URL_pums)\nstr(pums_info, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2024-10-07 02:02:25\"\n $ times      : Named num [1:6] 0 0.00292 0.09915 0.28703 0.52675 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nThis is a lot of information and not very clear or readable, so we will use the jsonlite package to parse this data.\n\nlibrary(jsonlite)\nlibrary(tibble)\n\n#parse data using rawToChar() function \nparsed &lt;- fromJSON(rawToChar(pums_info$content))\n\n#turn parsed data into nice tibble\nacs_estimates_info &lt;- as_tibble(parsed)\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\nacs_estimates_info\n\n# A tibble: 44,080 × 4\n   V1    V2    V3    V4   \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 SEX   PWGTP MAR   SCHL \n 2 2     6     5     24   \n 3 2     23    2     24   \n 4 1     23    3     24   \n 5 1     80    5     24   \n 6 1     16    1     24   \n 7 1     107   3     24   \n 8 2     10    5     24   \n 9 1     22    1     24   \n10 2     127   5     24   \n# ℹ 44,070 more rows\n\n\nThis is not quite what we want because the column names are “V1”, “V2”, “V3”, “V4”, default names, and the first row of observations are “SEX”, “PWGTP”, “MAR”, “SCHL”, are what should be the columns names. The following code will fix this:\n\nrow_length &lt;- nrow(acs_estimates_info)\n\nacs_estimates_info_updated &lt;- tibble(\"SEX\" = acs_estimates_info$V1[2:row_length], \"PWGTP\" = acs_estimates_info$V2[2:row_length], \"MAR\" = acs_estimates_info$V3[2:row_length], \"SCHL\" = acs_estimates_info$V4[2:row_length])\n\nacs_estimates_info_updated\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows\n\n\n\n\nNext we want to automate things. First we define a helper function which will take in a URL that accesses data from the PUMS API, and returns as output a nicely formatted tibble. Note that in the PUMS API, the data is always formatted with the first row consisting of the variable names, so we will need to take this into account for our helper function!\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ purrr     1.0.2\n✔ forcats   1.0.0     ✔ readr     2.1.5\n✔ ggplot2   3.5.1     ✔ stringr   1.5.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()  masks stats::filter()\n✖ purrr::flatten() masks jsonlite::flatten()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nurl_to_tibble &lt;- function(url = NULL, year = 2022) {\n    #us url to access data\n    raw_data &lt;- httr::GET(url)\n    \n    #data is given as a JSON file, so we need to parse it with rawToChar\n    #then format it as a tibble\n    parsed_data &lt;- fromJSON(rawToChar(raw_data$content))\n    base_tib &lt;- as_tibble(parsed_data)\n    \n    m &lt;- nrow(base_tib)\n    n &lt;- ncol(base_tib)\n    \n    #need to change column names of base_tib so that it matches the first row\n    for (i in 1:n) {\n      colnames(base_tib)[i] &lt;- base_tib[[1,i]]\n    }\n    \n    #now get rid of first row since they are not valid observations\n    updated_tib &lt;- base_tib[2:m, ]\n    \n    final_tib &lt;- updated_tib |&gt; \n      mutate(YEAR = as.character(year)) |&gt; \n      select(YEAR, everything())\n    \n    return (final_tib)\n}\n\nmy_tib &lt;- url_to_tibble(\"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX,MAR&SCHL=24\")\n\nThis works. Now we want to define a function that will query the PUMS API and allows the user to specify:\n\nyear of survey (with 2022 being the default year)\n\nneed to verify that the value given is between 2010 and 2022\n\nthe numeric variables to be returned (with AGEP and PWGTP as default, and PWGTP always being returned)\n\noptions for the user should be AGEP, GASP, GRPIP, JWAP (time), JWDP (time), and JWMNP\nfunction needs to turn variables into numeric values or time values where appropriate and check that the variables asked for are in the above set\none numeric variable other than PWGTP must also be returned\n\nthe categorical variables to be returned (with SEX as default)\n\noptions for the user should be FER, HHL, HISPEED, JWAP, JWDP, JWTRNS, SCH, SCHL, and SEX\nfunction needs to turn variables into factors with appropriate levels, where appropriate, and also check that the variables asked for are in the above set\none categorical variable must be returned\n\ngeography level (i.e. All, Region, Division, or STATE, with ALL as default)\n\nfunction needs to check that the value specified by the user is in the set above\n\nan optional argument to subset the data\n\nuser should be able to specify specific Regions, Divisions, or STATES for this part (and only those specified geography levels would be returned)\n\n\nIsaac added an optional user argument, geo_lev_value, which allows the user to subset the data by specific regions, divisions, or states, provided they select the corresponding geography level.\n\n#Need default arguments to build the url below\n#https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX\n#If user wants to specify a geography level (e.g. by state) other than the default\n#then the url should look something like\n#https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=state:* \n\nlibrary(stringi)\n\npums_url_builder &lt;- function(year = 2022, num_vars = c(\"AGEP\", \"PWGTP\"),\n                             cat_vars = c(\"SEX\"), geo_lev = \"all\", geo_lev_value = NULL) {\n  \n  #verify user input is valid\n  if (!(year %in% c(2010:2022))) {\n    stop(\"Year must be between 2010 and 2022!\")\n  }\n  else if (!all(is.element(num_vars, c(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \n                                          \"JWAP\", \"JWDP\", \"JWNMP\")))) {\n    stop(\"Numeric variables must be within the set {AGEP, PWGTP, GASP, GRPIP, \n         JWAP, JWDP, JWNMP}, and furthermore PWGTP must also be included.\")\n    if (!(is.element(\"PWGTP\", num_vars))) {\n      stop(\"PWGTP must always be included!\")\n    }\n  }\n  else if (!all(is.element(cat_vars, c(\"FER\", \"HHL\", \"HISPEED\", \"JWAP\", \n                                          \"JWDP\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"\n                                          )))) {\n    stop(\"Categorical variables must be within the set {FER, HHL, HISPEED, JWAP,\n         JWDP, JWTRNS, SCH, SCHL, SEX} and cannot be empty.\")\n    if (length(cat_vars) == 0) {\n      stop(\"At least one categorical variable must be returned!\")\n    }\n  }\n  else if (!all(is.element(geo_lev, c(\"all\", \"region\", \"division\", \"state\"\n                                         )))) {\n    stop(\"Geography level must be within the set {all, region, division, state}\n         .\")\n  }\n  \n  #base url: contains year only\n  base_url &lt;- paste(\"https://api.census.gov/data\", as.character(year), \"acs\", \"acs1\", \"pums?get=\", sep=\"/\")\n  \n  #create a string consisting of the numeric arguments chosen by user, then add \n  #this to base url\n  nums &lt;- \"\" #initialize empty string\n  for (i in 1:length(num_vars)){\n    nums &lt;- paste(nums,num_vars[i],sep=\",\")\n  }\n  nums &lt;- substr(nums, 2, stri_length(nums)) #delete \",\" in the beginning of nums\n  updated_url &lt;- paste0(base_url, nums)\n  \n  #do same for categorical arguments chose by user\n  chars &lt;- \"\" #initialize empty string\n  for (i in 1:length(cat_vars)){\n    chars &lt;- paste(chars,cat_vars[i],sep=\",\")\n  }\n  updated_url &lt;- paste0(updated_url, chars)\n  \n  #concatenate chosen geography level, and value for said level if given\n  if (geo_lev != \"All\") {\n    updated_url &lt;- paste0(updated_url, \"&for=\", geo_lev, \":\")\n    if (is.null(geo_lev_value) == FALSE) {\n      if (typeof(geo_lev_value) != \"character\") {\n        stop(\"Value for geography level must be of the form \\\"XX\\\", where X is a number between\n             0 and 9!\")\n      }\n      else if (stri_length(geo_lev_value) != 2) {\n        stop(\"Value for geography level must be of the form \\\"XX\\\", where X is a number between\n             0 and 9!\")\n      }\n      else if (!(is.element(unlist(strsplit(geo_lev_value, split=\"\"))[1], 0:9) | is.element\n               (unlist(strsplit(geo_lev_value,split=\"\"))[2], 0:9))) {\n        stop(\"Value for geography level must be of the form \\\"XX\\\", where X is a number between\n             0 and 9!\")\n      }\n      else {\n        updated_url &lt;- paste0(updated_url, as.character(geo_lev_value)) \n      }\n    }\n    else if (geo_lev == \"all\" & is.null(geo_lev_value) == FALSE) {\n      stop(\"You cannot specify a geography level value without picking a specific geography \n           level (i.e. region, division, or state.\")\n    }\n    else {\n      updated_url &lt;- paste0(updated_url, \"*\")\n    }\n  }\n\n  return(updated_url)\n}\npums_url_builder(geo_lev = \"state\", geo_lev_value = \"16\")\n\n[1] \"https://api.census.gov/data/2022/acs/acs1/pums?get=AGEP,PWGTP,SEX&for=state:16\""
  }
]